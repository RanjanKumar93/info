The `bufio` package in Go provides buffered I/O operations, which can significantly improve efficiency when reading or writing data. This package wraps around an `io.Reader` or `io.Writer` to provide buffering, reducing the number of I/O operations by storing intermediate data in memory.

### Concepts of `bufio`:

1. **`bufio.Reader`**:

   - Used for buffered reading from an `io.Reader` (e.g., a file or network stream).
   - It reads data into an internal buffer, allowing for more efficient reads.

2. **`bufio.Writer`**:

   - Used for buffered writing to an `io.Writer` (e.g., a file or network connection).
   - It writes data to a buffer first and flushes it to the underlying writer when necessary.

3. **`bufio.Scanner`**:
   - Scans data line-by-line or by custom token. Itâ€™s useful when reading input in chunks, like lines from a file.

---

### Example 1: Using `bufio.Reader` for buffered reading

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    reader := bufio.NewReader(file)
    for {
        line, err := reader.ReadString('\n')  // Reading until a newline character
        if err != nil {
            break  // Reached end of file or encountered an error
        }
        fmt.Print(line)
    }
}
```

#### Key functions:

- **`ReadString`**: Reads until the delimiter, which is a `byte` (in this case, `'\n'`).
- **`NewReader`**: Wraps an `io.Reader` to create a buffered reader.

---

### Example 2: Using `bufio.Writer` for buffered writing

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Create("output.txt")
    if err != nil {
        fmt.Println("Error creating file:", err)
        return
    }
    defer file.Close()

    writer := bufio.NewWriter(file)
    _, err = writer.WriteString("Hello, buffered writing in Go!\n")
    if err != nil {
        fmt.Println("Error writing to file:", err)
    }

    // Don't forget to flush the buffer
    writer.Flush()
}
```

#### Key functions:

- **`WriteString`**: Writes a string to the buffer.
- **`Flush`**: Flushes buffered data to the underlying writer.

---

### Example 3: Using `bufio.Scanner` for reading line by line

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        fmt.Println(scanner.Text())  // Print each line
    }

    if err := scanner.Err(); err != nil {
        fmt.Println("Error reading file:", err)
    }
}
```

#### Key functions:

- **`Scan`**: Advances the scanner to the next token (by default, a line).
- **`Text`**: Returns the most recent token generated by a call to `Scan`.
- **`Err`**: Checks for any errors encountered during scanning.

---

### Example 4: Customizing `bufio.Scanner` to split by words

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    data := "This is a custom scanner example."
    scanner := bufio.NewScanner(strings.NewReader(data))

    // Define custom split function for scanning words
    scanner.Split(bufio.ScanWords)

    for scanner.Scan() {
        fmt.Println(scanner.Text())  // Print each word
    }

    if err := scanner.Err(); err != nil {
        fmt.Println("Error scanning data:", err)
    }
}
```

#### Key functions:

- **`Split`**: Sets a custom split function, like `bufio.ScanWords`, `bufio.ScanLines`, etc.

---

### Key Points:

- **Buffer Size**: `bufio.Reader` and `bufio.Writer` have a default buffer size (usually 4096 bytes). You can change it with `bufio.NewReaderSize` or `bufio.NewWriterSize`.
- **Efficiency**: Buffered I/O minimizes system calls by working with larger chunks of data at a time, which can be critical when dealing with I/O-bound operations.
